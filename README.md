# Архитектура проекта

> **Цель документа** — зафиксировать правила архитектуры, чтобы решения были единообразными, а ревью — быстрыми.

---

## Содержание
1. [Модульная архитектура](#модульная-архитектура)
2. [Внедрение зависимостей](#внедрение-зависимостей)
3. [Clean Architecture и Use Cases](#clean-architecture-и-use-cases)
4. [Игровые сущности MVC](#игровые-сущности-mvc)
5. [UI MVP](#ui-mvp)
6. [Асинхронность](#асинхронность)
7. [Структура проекта](#структура-проекта)

---

## Модульная архитектура

### Определение модуля
**Модуль** = **функциональная область** + **публичный API**.

- Модуль не «просто папка», а **самодостаточная часть** проекта.
- Внешний код должен зависеть **только от API** модуля, а не от внутренних деталей.

### Assembly Definition
- **Каждый модуль отделяется своей Assembly Definition** (`.asmdef`).

✅ **Плюсы**
- Явные зависимости между модулями
- Быстрее компиляция
- Проще поддерживать границы и ответственность

---

## Внедрение зависимостей

### Правило
Для внедрения зависимостей используем **DI (Zenject)**.

### Где лежат биндинги
- В каждом модуле есть папка **`Installers`** с Zenject-инсталлерами этого модуля.
- Запрещается **«рандомный Bind в любом месте»** — биндинги делаем **только** в `Installers`.

---

## Clean Architecture и Use Cases

### Когда нужен слой Use Cases
- Для сложных связей между **одноуровневыми модулями** ориентируемся на **Clean Architecture** и используем слой **Use Cases**.

### Где живут Use Cases
- **Use Cases живут в Root Module** только для **cross-module** сценариев (оркестрация между модулями).
- Root UseCases должны зависеть **только от интерфейсов модулей (API)**, а не от их внутренностей.

### Пример
Камера должна реагировать на приседание, но не должна знать о модуле игрока. Use Case соединяет камеру и игрока без лишних модульных зависимостей.

---

## Игровые сущности MVC

### Роли
- **Model**: чистая логика. Желательно без Unity.
- **View**: `MonoBehaviour`, анимация/рендер/VFX и т.д.
- **Controller**: связывает ввод/события и вызывает `UseCases`/`Model`.

### Правила
- `Controller` создаётся через DI (или фабрику DI) и **владеет** `Model`.
- `View` создаётся Unity (на сцене/префабе), но **не создаёт** `Model`/`Controller`.

---

## UI: MVP

### MVP (по умолчанию)
- **View**: не содержит логики, только события UI и методы `Render`.
- **Presenter**: связывает ввод/события с UI, вызывает `UseCases`/`Model`, обновляет состояние экрана и вызывает `Render`.

**Дополнение**
- `Presenter` не должен напрямую лазить в Unity-компоненты (типа `button.interactable = ...`) — только через методы `View`.  
  Иначе MVP превращается в «скрипт на канвасе».

### MVVM
Для UI пока используем MVP, если поймем, что будет много сложного UI, добавим MVVM

---

## Асинхронность

### Правила
- Для асинхронного кода **не используем корутины**, используем **async/await** в связке с **UniTask**.
- `async void` запрещён — используем **`UniTaskVoid`** и `Forget()` для fire-and-forget задач.
- Долгие операции обязаны принимать **`CancellationToken`**.

---

## Структура проекта

В проекте основная папка **`_Main`** находится в `Assets`. В ней лежат наши ассеты (скрипты/модели/материалы и т.д.):

```
Assets/_Main/Animations/
Assets/_Main/Audio/
Assets/_Main/Configs/
Assets/_Main/Icons/
Assets/_Main/Materials/
Assets/_Main/Models/
Assets/_Main/PhysicsMaterials/
Assets/_Main/Prefabs/
Assets/_Main/Scenes/
Assets/_Main/Scripts/
Assets/_Main/VFX/
```

Все сторонние ассеты по умолчанию попадают в папку `Assets`. Так мы отделяем нашу часть приложения.
